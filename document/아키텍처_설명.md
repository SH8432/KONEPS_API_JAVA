# 나라장터 API 프로젝트 – 실무형 코드 분리 설명

이 문서는 `src/main/java` 내부 소스를 **유지보수·추가 개발**을 염두에 두고, 실무에서 많이 쓰는 방식으로 어떻게 나누었는지, **왜 그렇게 했는지**를 정리한 것입니다.

---

## 1. 전체 패키지 구조

```
com.example.nara
├── config/       … 설정 (URL, API 키)
├── dto/          … 데이터 모델 (결과 DTO, 컬럼 정의)
├── client/       … HTTP 호출만 담당
├── parser/       … API JSON 응답 파싱만 담당
├── service/      … 비즈니스 로직·오케스트레이션
└── ui/           … Swing 화면·이벤트·CSV 저장
```

- **한 패키지/한 클래스는 한 가지 역할**에 가깝게 두었습니다.
- **의존 방향**: `ui → service → client, parser` / `service, client, parser → config, dto`  
  UI는 Service만 알고, Service는 Client·Parser·Config·DTO만 알고, UI·Swing은 Service 아래에만 있습니다.

---

## 2. 계층별 역할과 “왜 이렇게 나눴는지”

### 2.1. `config` – 설정

| 파일 | 역할 |
|------|------|
| `NaraApiConfig` | API 기본 URL, 인증 키(서비스키) 제공 |

**왜 분리했는지**

- **한 곳에서만 설정 변경**: URL·키가 바뀌어도 `NaraApiConfig`만 수정하면 됩니다.
- **보안**: API 키를 소스에 직접 박지 않고, 환경변수(`NARA_SERVICE_KEY`)·시스템 프로퍼티(`nara.service.key`)로 줄 수 있게 했습니다. 실무에서는 배포 시 이 값만 바꿔서 넣는 경우가 많습니다.
- **테스트/운영 분리**: 로컬은 기본값, 운영은 환경변수로 다른 키를 쓰는 식으로 나누기 쉽습니다.

---

### 2.2. `dto` – 데이터 모델

| 파일 | 역할 |
|------|------|
| `GridResult` | 그리드용 API 결과 (결과코드, 페이지 정보, 행 목록) |
| `BidItemColumn` | API 필드 키 목록·한글 컬럼명 매핑 (테이블/CSV 헤더용) |

**왜 분리했는지**

- **API 결과 구조를 한 타입으로 고정**: `GridResult` 하나로 “헤더 메타 + 행 리스트”를 전달해서, UI나 다른 호출부가 같은 형태로만 사용하게 했습니다.
- **컬럼 추가/변경이 한 곳에만 생기게**: 컬럼을 늘리거나 이름을 바꿀 때 `BidItemColumn`만 수정하면, 테이블·CSV·필터링이 모두 같은 정의를 쓰게 됩니다.
- **UI와 무관한 모델**: DTO는 Swing을 전혀 모르므로, 나중에 JavaFX나 웹으로 바꿔도 그대로 재사용할 수 있습니다.

---

### 2.3. `client` – HTTP 호출

| 파일 | 역할 |
|------|------|
| `NaraApiClient` | GET 요청으로 API URL 호출 → 응답 본문(JSON 문자열)만 반환 |

**왜 분리했는지**

- **HTTP만 책임지게**: URL 조립·타임아웃·에러 코드 처리만 Client가 하고, “무슨 API인지·어떤 비즈니스 규칙인지”는 모르게 했습니다.
- **테스트·교체가 쉬움**: 실제 API 대신 Mock/Stub HTTP를 넣어서 Service 단위 테스트를 만들기 좋습니다. 실무에서는 이런 식으로 HTTP 계층만 바꿔서 테스트하는 경우가 많습니다.
- **재사용**: 같은 나라장터 API를 배치 작업·다른 화면에서 쓸 때도 이 Client 하나만 쓰면 됩니다.

---

### 2.4. `parser` – JSON 파싱

| 파일 | 역할 |
|------|------|
| `NaraResponseParser` | JSON 문자열 → `response`/`header`/`body`/`items` 추출, 필드 문자열 읽기 |

**왜 분리했는지**

- **API 응답 형식 변경 시 수정 범위 최소화**: 공공 API 스펙이 바뀌어도 “파싱 로직”은 `NaraResponseParser`에만 있으므로, 여기만 고치면 됩니다.
- **Service는 “의미”만 다루게**: Service는 “결과코드·페이지·행 리스트” 같은 비즈니스 개념만 다루고, “JSON 키 이름·중첩 구조” 같은 건 Parser에 맡깁니다.
- **파싱 단위 테스트**: JSON 문자열만 넣고 파싱 결과만 검증하는 테스트를 Parser에만 집중해서 만들 수 있습니다.

---

### 2.5. `service` – 비즈니스·오케스트레이션

| 파일 | 역할 |
|------|------|
| `NaraApiService` | Client 호출 + Parser 사용 + 그리드용 변환·필터(최소 배정예산 등)·여러 페이지 수집 |

**왜 분리했는지**

- **UI와 API 사이의 “애플리케이션 로직” 한 곳에 모음**:  
  “한 번 호출해서 그리드로 보여주기”, “최소 금액 필터 걸고 여러 페이지 다 가져오기” 같은 흐름은 모두 Service에서만 처리합니다.
- **UI는 “무엇을 할지”만 알게 함**: UI는 “조회해줘”, “이 조건으로 전체 가져와줘”만 요청하고, 페이지네이션·필터·재호출 전략은 Service가 담당합니다.
- **다른 진입점에서 재사용**: 배치·REST API·다른 UI(JavaFX 등)를 붙일 때도 같은 Service를 쓰면 동일한 비즈니스 규칙이 적용됩니다.
- **인스턴스 하나로 사용**: `NaraApiService.getInstance()`로 한 인스턴스를 쓰도록 해서, 나중에 DI(Spring 등)로 바꿀 때도 교체 지점이 명확합니다.

---

### 2.6. `ui` – 화면·이벤트·파일 저장

| 파일 | 역할 |
|------|------|
| `NaraGetSwing` | Swing 창/테이블/버튼 구성, 조회·페이지 이동·CSV 저장 이벤트, Service 호출 |

**왜 분리했는지**

- **UI 변경이 비즈니스 로직에 영향 안 주게**: 레이아웃·컴포넌트를 바꿔도 Service·Client·Parser는 그대로 둘 수 있습니다.
- **Swing 의존성 한 곳에만**: Swing을 쓰는 코드는 `ui` 패키지에만 두어서, 나중에 다른 UI 기술로 바꿀 때 `ui`만 교체하면 됩니다.
- **테스트**: Service까지 Mock으로 두고 “버튼 클릭 시 이 파라미터로 Service가 호출되는지”만 검증하는 UI 테스트를 작성하기 좋습니다.

---

## 3. 의존성 방향 요약

```
ui (NaraGetSwing)
  → service (NaraApiService)
       → client (NaraApiClient)
       → parser (NaraResponseParser)
       → config (NaraApiConfig)
       → dto (GridResult, BidItemColumn)
```

- **아래로만 의존**: UI는 Service만, Service는 Client·Parser·Config·DTO만 참조합니다.  
  Config/DTO/Client/Parser는 UI를 전혀 모릅니다.
- 그렇게 해서 **변경이 한 방향으로만 퍼지게** 하고, **테스트·교체**를 계층별로 나누기 쉽게 했습니다.

---

## 4. 실무에서 이렇게 나누는 이유 정리

| 목적 | 이 구조가 주는 이점 |
|------|---------------------|
| **유지보수** | API 스펙 변경 → Parser/Client, 컬럼 변경 → DTO, 키/URL 변경 → Config만 수정하면 됨. |
| **추가 개발** | 새 화면·새 API·새 필터를 넣을 때 해당 계층만 확장하면 됨. |
| **테스트** | Client·Parser·Service를 UI 없이 단위 테스트하기 쉬움. |
| **보안** | API 키를 Config에서 환경변수/설정으로 분리해, 소스에 안 박을 수 있음. |
| **재사용** | Service·Client·DTO는 Swing과 무관하므로, 배치·웹·다른 UI에서 그대로 사용 가능. |

---

## 5. 실행 방법

- **메인 클래스**: `com.example.nara.ui.NaraGetSwing`
- **API 키**:  
  - 환경변수 `NARA_SERVICE_KEY` 또는  
  - JVM 옵션 `-Dnara.service.key=키값`  
  을 주면 그 값을 사용하고, 없으면 `NaraApiConfig`의 기본값을 사용합니다.

이 구조를 기준으로 두고, 기능이 늘어나면 각 계층만 확장하면 됩니다.
